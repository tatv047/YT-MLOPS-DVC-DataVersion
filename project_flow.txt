1. Create git repo and clone it in local
2. Create imp_code.py and add code to it .(it'll save a csv file to a new "data" folder)
> the explaination of the code in imp_code.py is as follows:-
    In your code, the `os` module is used for **handling file paths and directory creation** in a cross-platform way. Let’s break it down step by step.

    1. Importing Required Modules

    ```python
    import pandas as pd
    import os
    ```
    - `pandas` is imported for handling tabular data.
    - `os` is imported to interact with the operating system.

    2. Creating a Sample DataFrame

    ```python
    data = {'Name':['Alice','Bob','Charlie'],
            'Age' : [25,30,35],
            'City': ['NYC','LA','DC']}

    df = pd.DataFrame(data)
    ```
    - This creates a simple DataFrame with three columns: `'Name'`, `'Age'`, and `'City'`.

    3. Ensuring the Directory Exists

    ```python
    data_dir = 'data'
    os.makedirs(data_dir, exist_ok=True)
    ```

    - `os.makedirs(data_dir, exist_ok=True)` ensures that a directory named `'data'` exists.
    - If `'data'` does not exist, it creates the directory.
    - `exist_ok=True` prevents an error if the directory already exists.

    Why use `os.makedirs`? 
    - It makes sure the directory is created before saving the file.
    - It works on all operating systems (Windows, macOS, Linux).

    4. Constructing the File Path

    ```python
    file_path = os.path.join(data_dir, 'sample_data.csv')
    ```
    - `os.path.join()` constructs a valid file path in a cross-platform way.
    - On Windows, it returns `'data\\sample_data.csv'` (using `\` as a separator).
    - On macOS/Linux, it returns `'data/sample_data.csv'` (using `/` as a separator).

    Why use `os.path.join()`?
    - Avoids hardcoding file paths, ensuring compatibility across different OS.

    5. Saving the DataFrame to a CSV File

    ```python
    df.to_csv(file_path, index=False)
    ```
    - Saves the DataFrame as a CSV file in the `'data'` directory.
    - `index=False` prevents pandas from adding an extra index column.

    6. Printing the Saved File Path

    ```python
    print(f"csv file saved to : {file_path}")
    ```
    - This confirms that the CSV file was successfully saved.

    Summary of `os` Module Usage
    1. **`os.makedirs(data_dir, exist_ok=True)`** → Ensures the `'data'` directory exists.
    2. **`os.path.join(data_dir, 'sample_data.csv')`** → Constructs a valid file path.

    Why is `os` useful here?
    - It ensures that your code works on different operating systems.
    - It prevents errors by automatically creating missing directories.
    - It makes file paths dynamic rather than hardcoded.

3. Do a git add-commit-push before initialising DVC.
4. Now we do "dvc init" (creates .dvcignore, .dvc)
5. Now do "mkdir S3" (create a new S3 directory) .
    > Now DVC has to be told where it's remote origin is, for the ease here,
    we have created a S3 folder here, and will set our remote origin to it.
6. Now we do "dvc remote add -d myremote S3" .
7. Next "dvc add data/"
    > this simply means that after commiting, track all files inside the "data" folder 
    everytime it changes. dvc is responsible the versioning.
    > after hitting enter you'll get an error : git is already tracking it.
    > you need to stop git from tracking it using
    "git rm -r --cached 'data'
    git commit -m "stop tracking data""
8. Again we do "dvc add data/" again, then "git add data.dvc .gitignore" to track version IDs.
9. Now do "dvc commit" and then "dvc push".
    > 2 files(data) get pushed in S3. But why 2?
    > one file is the unique token , the other file is the data itself.
10. Do a git add-commit-push to mark this stage as first versio of the data.
11. Now make chnages to the imp_code.py to append a new row of data, check changes via "dvc status"